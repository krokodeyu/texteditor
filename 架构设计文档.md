# 文本编辑器架构设计文档

> 本项目整体采用基于 Rust 的面向对象设计：以 `Editor` / `Workspace` / `Application` 为领域对象，结合 Command / Memento / Observer 等经典设计模式，实现可扩展的命令行文本编辑器架构。

---

## 1. 设计目标与约束

- 提供一个**基于 REPL 的简易文本编辑器**，支持多文件、活动编辑器切换，以及基本文本操作（append / insert / delete / replace / show / save / dir-tree 等）。

- 通过 **命令行指令** 驱动，而不是交互式光标编辑。

- 结构上满足 lab1 要求：
  
  - 分为接口层、领域层、基础设施三层；
  
  - 使用 **Command、Memento、Observer** 等模式；
  
  - 支持统一的 **错误类型 AppError + AppResult**；
  
  - 通过 JSON 文件 `.editor_workspace` 存储工作区快照；
  
  - 通过事件总线和 Logger 记录命令/错误日志。

- 保持 **命令可扩展**：新增命令不需要修改主循环与 Application 结构，只需注册 handler。

---

## 2. 总体架构概览

整体架构可分为三层：

1. **接口层（Application + Router）**
   
   - 负责：读用户输入 → 解析为命令 + 参数 → 分发给对应 handler → 收集 Outcome（输出/日志/退出标志）。

2. **领域层（Workspace + Editor + DocCommand）**
   
   - Workspace 管理多文件与活动编辑器，以及工作区 Memento；
   
   - Editor 以 `Vec<String>` 存储文本行，负责具体编辑操作与 undo/redo；
   
   - 文档操作以 DocCommand 命令对象形式存在，支持撤销/重做。

3. **基础设施层（EventBus + Logger + Persist + Error）**
   
   - EventBus & Logger 实现 Observer 模式，用于按文件 / 全局日志；
   
   - Persist 模块负责 WorkspaceMemento 的 JSON 读写；
   
   - Error 模块统一应用错误类型，main 中集中处理。

数据流大致为：

```text
stdin -> Application::run (REPL)
      -> Router::resolve(line) -> (handler, args)
      -> handler(&mut Application, &args)  // 各种命令
            -> Workspace / Editor / DocCommand
            -> 返回 Outcome { print, log, exit }

Application 根据 Outcome:
  - print -> stdout
  - log   -> EventBus.publish(Event::Command{ file, cmd })
  - exit  -> save_workspace_memento() & break

错误路径:
  handler 返回 Err(AppError)
  -> Application::publish_error()
     - e.report()
     - EventBus.publish(Event::Error{ code, message })
```

---

## 3. 分层设计

### 3.1 接口层：Application + Router

#### Application

`Application` 是 REPL 入口层，持有：

```rust
pub struct Application {
    pub router: Router,
    pub workspace: Workspace,
    pub bus: EventBus,
}
```

职责：

- 在 `new()` 中：
  
  - 初始化 `Workspace`（含 `base_dir`，例如 `work_dir`）；
  
  - 初始化 `EventBus` 并注册 `Logger`；
  
  - 从 `base_dir/.editor_workspace` 中读取 `WorkspaceMemento`，恢复工作区。

- 在 `run()` 中：
  
  - 循环读取用户输入行；
  
  - 使用 `router.resolve(line)` 解析命令名 + 参数；
  
  - 调用 handler：`handler(self, &args) -> AppResult<Outcome>`；
  
  - 根据 Outcome 统一做输出与日志：
    
    - `print` → `println!`
    
    - `log` → 发布 `Event::Command { file: workspace.active_file_path(), cmd }`
    
    - `exit = true` → 调用 `save_workspace_memento()`，然后退出循环

- 在错误路径：
  
  - 捕获 `AppError`，调用 `publish_error`：
    
    - `e.report()`：打印友好错误信息
    
    - `bus.publish(Event::Error { code, message })`：交给 Logger 写 .app.log

#### Router

Router 实现命令路由表，替代“大 match”：

- 命令统一定义为：
  
  ```rust
  pub type Handler = fn(&mut Application, &[String]) -> AppResult<Outcome>;
  
  pub struct CommandDef {
      pub name: &'static str,
      pub handler: Handler,
  }
  ```

- `commands/mod.rs` 中维护一个静态命令表：
  
  ```rust
  pub static COMMANDS: &[CommandDef] = &[
      APPEND_COMMAND,
      LOAD_COMMAND,
      SAVE_COMMAND,
      EXIT_COMMAND,
      UNDO_COMMAND,
      REDO_COMMAND,
      DIR_TREE_COMMAND,
      LOG_ON_COMMAND,
      LOG_OFF_COMMAND,
      LOG_SHOW_COMMAND,
      // ...
  ];
  ```

- Router 在初始化时构建 `HashMap<String, Handler>`：
  
  - key：命令名字符串；
  
  - value：对应的 handler 函数指针。

- `resolve(line: &str) -> AppResult<(Handler, Vec<String>)>`：
  
  - 使用 shell-like 分词（支持用引号包裹文本参数）；
  
  - 第一个 token 为命令名，后面为参数；
  
  - 查表取出 handler，返回 `(handler, args)`。

新增命令流程：

1. 在 `commands/xxx.rs` 中实现 `pub fn cmd_xxx(...) -> AppResult<Outcome>`；

2. 定义 `pub const XXX_COMMAND: CommandDef`；

3. 在 `commands/mod.rs` 的 `COMMANDS` 数组中添加一行。

Application 和 Router 本身无需改动。

---

### 3.2 领域层：Workspace + Editor + DocCommand

#### Workspace

Workspace 管理**多文件编辑器集合**以及工作区快照：

```rust
pub struct Workspace {
    editors: HashMap<PathBuf, Editor>,
    active: Option<PathBuf>,
    base_dir: PathBuf,
}
```

主要职责：

- 路径解析：
  
  - `resolve_path(Some(arg))`：如果相对路径 → 拼到 `base_dir`；
  
  - `resolve_path(None)`：返回 `base_dir`。

- 文件管理命令：
  
  - `load <file>`：存在则读入为 Editor，不存在则新建空 Editor；设置为 active；
  
  - `save [file|all]`：写回磁盘，并清除 `modified` 标志；
  
  - `edit <file>`：切换 active editor；
  
  - `close [file]`：关闭指定或当前文件；
  
  - `editor-list`：列出当前打开的文件。

- 工作区 Memento：
  
  - `to_memento()`：输出 `WorkspaceMemento { open_files, active }`；
  
  - `from_memento(m: WorkspaceMemento)`：按快照恢复打开文件及其 logging/modified 状态（内容从磁盘读取）。

- 文档命令执行 & undo/redo：
  
  - `exec_doc(cmd: Box<dyn DocCommand>)`：
    
    - 在当前 active editor 上执行 `cmd.execute`；
    
    - 将命令压入 `undo_stack`；
    
    - 清空 `redo_stack`；
  
  - `undo()` / `redo()`：转发给 active editor，并更新命令栈。

- 日志控制：
  
  - `log_on(path)` / `log_off(path)`：打开/关闭某文件的 logging 标志；
  
  - `log_show(path)`：根据 `base_dir/.filename.log` 读取该文件日志内容。

#### Editor

Editor 是**单文件文本编辑器**，使用行数组存储内容：

```rust
pub struct Editor {
    lines: Vec<String>,
    modified: bool,
    logging: bool,

    undo_stack: Vec<Box<dyn DocCommand>>,
    redo_stack: Vec<Box<dyn DocCommand>>,
}
```

核心职责：

- 文本存储：
  
  - `append_line(&str)` / `pop_line()`；
  
  - `insert_text(line, col, text)`：在指定行列插入文本（字节列）；
  
  - `delete_text(line, col, len)`：删除指定范围字节；
  
  - `peek_text(line, col, len)`：只读查看指定片段；
  
  - `to_string()` / `show(start, end)`：用于 `show` 命令输出文本。

- 状态字段：
  
  - `modified`：是否有未保存修改；
  
  - `logging`：该文件命令是否需要写 per-file log。

- 命令执行 + 撤销/重做（Command 模式）：
  
  - `exec_doc(cmd: Box<dyn DocCommand>)`：
    
    - 执行 `cmd.execute(self)`；
    
    - `undo_stack.push(cmd)`；
    
    - `redo_stack.clear()`；
  
  - `undo()`：
    
    - 从 `undo_stack` 弹出一个命令，调用 `cmd.undo(self)`；
    
    - 将其压入 `redo_stack`；
  
  - `redo()`：
    
    - 从 `redo_stack` 弹出一个命令，调用 `cmd.execute(self)`；
    
    - 将其压回 `undo_stack`。

#### DocCommand

文档操作命令接口：

```rust
pub trait DocCommand {
    fn execute(&mut self, ed: &mut Editor) -> AppResult<()>;
    fn undo(&mut self, ed: &mut Editor) -> AppResult<()>;
}
```

典型实现：

- `AppendLineCommand`：
  
  - execute：记录原始行数 `line_index = ed.count_lines()`，将新行 append；
  
  - undo：调用 `ed.pop_line()` 删除最后一行。

- `InsertTextCommand` / `DeleteTextCommand` / `ReplaceTextCommand`：
  
  - insert：只需记录插入位置与文本长度，undo 时 delete；
  
  - delete：执行前通过 `peek_text` 记录被删除内容，undo 时在原位置 insert 回去；
  
  - replace：execute 前 `peek` 旧文本 → delete 旧文本 → insert 新文本；undo 时 delete 新文本 → insert 旧文本。

---

### 3.3 基础设施层：EventBus + Logger + Persist + Error

#### Event & EventBus（Observer 模式）

事件定义：

```rust
pub enum Event {
    SessionStart,
    Command { file: Option<PathBuf>, cmd: String },
    Error { code: u32, message: String },
}
```

EventBus：

```rust
pub struct EventBus {
    subscribers: Vec<Box<dyn Subscriber>>,
}
```

- `subscribe(Box<dyn Subscriber>)`：注册观察者；

- `publish(&Event)`：广播事件给所有订阅者。

`Logger` 实现 `Subscriber`，订阅事件并写日志。

#### Logger

Logger 负责按文件与全局日志：

- 构造时持有 `base_dir: PathBuf`；

- 日志文件策略：
  
  - 会话头（SessionStart）：首次写入时在 `.app.log` 写入 “session start at ...”；
  
  - 按文件日志（Command）：
    
    - `Event::Command { file: Some(path), cmd }`：
      
      - 取文件名，如 `main.rs`；
      
      - 写入 `base_dir/.main.rs.log`；
      
      - 首次写入该文件时添加会话头；
    
    - `Event::Command { file: None, ... }`：
      
      - 写入 `base_dir/.app.log`；
  
  - 错误日志（Error）：
    
    - `Event::Error { code, message }`：
      
      - 统一写入 `base_dir/.app.log`。

任何 I/O 错误只打印 `[warn]`，不中断主流程。

#### Persist：WorkspaceMemento（Memento 模式）

`WorkspaceMemento` 负责工作区快照持久化：

```rust
pub struct WorkspaceMemento {
    pub open_files: HashMap<PathBuf, FileFlags>,
    pub active: Option<PathBuf>,
}

pub struct FileFlags {
    pub modified: bool,
    pub logging: bool,
}
```

- 使用 `serde` / `serde_json` 将 WorkspaceMemento 存为 JSON 文件：
  
  - 路径：`base_dir/.editor_workspace`。

- Application 启动时：
  
  - 若文件存在，`WorkspaceMemento::load(path)` 读取 JSON；
  
  - 调用 `workspace.from_memento(memento)` 恢复状态。

- 退出时（exit 命令）：
  
  - 调用 `workspace.to_memento()` 产生快照；
  
  - 写入 `.editor_workspace`。

#### Error：AppError + AppResult

统一错误类型：

```rust
#[derive(thiserror::Error, Debug)]
pub enum AppError {
    #[error("IO error: {0}")]
    Io(#[from] std::io::Error),

    #[error("invalid args: {0}")]
    InvalidArgs(String),

    // ... 其他错误类型
}

pub type AppResult<T> = Result<T, AppError>;
```

- 提供 `code(&self) -> u32`，用于错误事件分类；

- 提供 `report(&self)`，用于在 Application 中输出用户可读的信息；

- 所有命令处理函数与核心操作统一返回 `AppResult<T>`，通过 `?` 自动向上冒泡。

---

## 4. 设计模式应用小结

- **Command 模式（命令模式）**
  
  - 文本变更命令（append / insert / delete / replace）实现 `DocCommand`；
  
  - `Editor` 使用 `undo_stack` 和 `redo_stack` 记录命令历史，实现撤销/重做；
  
  - 上层命令（如 `append`）仅构造 DocCommand 并通过 `Workspace::exec_doc` 交给 Editor 执行，应用层逻辑与具体编辑实现解耦。

- **Memento 模式**
  
  - `WorkspaceMemento` 作为工作区状态快照，只保存：
    
    - 哪些文件是打开的；
    
    - 哪个是 active；
    
    - 每个文件是否 modified / logging。
  
  - Application 启动/退出时在 `.editor_workspace` 与内存中的 Workspace 状态之间转换。

- **Observer 模式**
  
  - `EventBus` + `Logger` 实现事件发布/订阅；
  
  - Editor/Workspace/命令层无需直接操作文件日志，只负责发布命令/错误事件；
  
  - Logger 监听事件并写入 `.filename.log` 与 `.app.log`，职责单一、不入侵业务逻辑。

- **命令路由替换“大 switch/match”**
  
  - Router 利用静态 `COMMANDS` 数组建立 name -> handler 映射；
  
  - 新增命令只需新增模块 + CommandDef 注册一行；
  
  - Application 与 Router 不需要修改，符合开闭原则（OCP）。

---

## 5. 启动与退出流程

### 启动流程（Application::new）

1. 创建 `Workspace`，设定 `base_dir`（例如 `work_dir`），确保目录存在（`create_dir_all`）。

2. 初始化 `EventBus`，注册基于 `base_dir` 的 `Logger`。

3. 检查 `base_dir/.editor_workspace`：
   
   - 如存在：`WorkspaceMemento::load` 读取 JSON；
   
   - `workspace.from_memento(m)` 恢复打开文件列表与 logging 状态。

4. 构造 `Application { router, workspace, bus }`。

### 退出流程（exit 命令）

1. 命令 handler 返回 `Outcome { exit: true, .. }`；

2. Application 在处理 Outcome 时：
   
   - 调用 `save_workspace_memento()`：
     
     - `workspace.to_memento()` 生成快照；
     
     - 写入 `base_dir/.editor_workspace`；
   
   - 打印 `[info] workspace saved ...`；
   
   - 跳出 REPL 循环结束运行。

---

## 6. 可测试性与扩展性

- **Editor 层**
  
  - 提供纯内存操作（`insert_text` / `delete_text` / `peek_text` / undo/redo），可通过单元测试验证边界情况与命令栈行为；

- **Workspace 层**
  
  - 通过临时目录（`tempdir`）构造 `base_dir`，测试 `resolve_path` / `save_file` / `save_all` / `log_show` 的文件系统行为；

- **命令与 Application 层**
  
  - 通过直接调用命令 handler（`cmd_load/cmd_append/cmd_undo/cmd_save`）构造 end-to-end 测试，验证从命令到 Workspace/Editor 的完整链路。

扩展方向：

- 基于现有 Command/Memento/Observer 结构，可以较小成本新增：
  
  - 更多编辑命令（块操作、查找替换等）；
  
  - 不同显示命令（分页 show、带高亮等）；
  
  - 不同持久化后端（例如改为 SQLite 存储 workspace memento）；
  
  - 一个application兼容多个工作区。
