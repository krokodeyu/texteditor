# 文本编辑器测试文档（含随机用户层测试）

## 1. 测试概述

### 1.1 被测系统

- 系统名称：命令行文本编辑器（Rust，Lab1）

- 主要功能：
  
  - 多文件编辑：`load`、`edit`、`close`、`editor-list`
  
  - 文本编辑：`append`、`show`，以及基于命令模式的 `undo` / `redo`
  
  - 工作区快照：`.editor_workspace` 的保存与恢复
  
  - 目录树显示：`dir-tree`
  
  - 日志功能：`log-on` / `log-off` / `log-show`
  
  - 错误处理：未知命令、参数错误等

### 1.2 测试目标

- 验证核心模块（Editor / Workspace / Application）的逻辑正确性；

- 验证错误输入情况下系统不会崩溃或破坏数据；

- 通过**随机用户行为测试（Fuzz 测试）**验证程序在大量随机命令序列下仍能稳定运行。

### 1.3 测试环境

- 操作系统：Windows 11（64-bit）

- Rust：stable 1.91.0（根据实际环境填写）

- 构建工具：Cargo 1.91.0

- 构建方式：`cargo build`

- Rust 单元测试：`cargo test`

- 随机用户层测试：
  
  - Python 3.13.2
  
  - 使用脚本：`tests/random_test.py`

---

## 2. 测试范围与方法

### 2.1 范围

1. **Editor 层**
   
   - 行数组存储与基本操作（append/pop/insert/delete/peek）
   
   - 越界检查
   
   - `DocCommand` + `undo_stack` / `redo_stack` 的行为

2. **Workspace 层**
   
   - `base_dir` / `work_dir` 行为
   
   - 路径解析：相对/绝对路径、`None`
   
   - `save_file` / `save_all`
   
   - `log_show` 读取 per-file `.filename.log`

3. **Application 层**
   
   - `save_workspace_memento` 写入 `.editor_workspace`
   
   - 成功命令发布 `Event::Command`
   
   - 错误发布 `Event::Error`

4. **用户层随机测试（Fuzz 测试）**
   
   - 脚本 `tests/random_cli_fuzz.py` 随机生成用户命令序列：
     
     - 命令包括：`load`、`append`、`init`、`editor-list`、`show`、`edit`、`save`、`undo`、`redo`、`dir-tree`、`log-on`、`log-off`、`log-show`、以及随机垃圾命令；
     
     - 参数完全随机（文件名、路径、文本内容等随机生成）；
   
   - 检查程序是否：
     
     - 不崩溃（退出码 0），无 panic；
     
     - 随机抽查 session 日志与工作目录，未发现明显逻辑错误。

### 2.2 测试方法

- **单元测试（白盒）**
  
  - 利用 Rust 内嵌 `#[cfg(test)]` 模块：
    
    - 在 `editor.rs` 中测试行操作与 undo/redo；
    
    - 在 `workspace.rs` 中测试路径解析、保存、日志读取；
    
    - 在 `application.rs` 中测试 memento 保存与事件发布逻辑。
  
  - 执行命令：`cargo test`

- **随机测试（黑盒，Fuzz 风格）**
  
  - 使用 Python 脚本 `tests/random_cli_fuzz.py`：
    
    - 编译可执行文件：`cargo build`
    
    - 在项目根目录运行：`python tests/random_cli_fuzz.py`
  
  - 脚本行为：
    
    - 多个 session，每个 session 在独立工作目录下运行；
    
    - 每个 session 生成一串随机命令（最终自动追加 `exit`）；
    
    - 捕获 stdout / stderr / exit code；
    
    - 将命令和结果记录到 `fuzz_runs/session_<i>.log` 中，便于人工审查。

---

## 3. 用例列表与执行结果

> 说明：
> 
> - “实际结果”基于当前版本代码实际运行情况填写；
> 
> - 如果后续修改了代码，可在这份文档上更新“实际结果 / 结论”列。

### 3.1 Editor 层测试用例

#### TC-E01：append_line / pop_line 基本行为

- **模块**：Editor

- **用例编号**：TC-E01

- **用例名称**：追加与弹出行的基本行为

- **前置条件**：
  
  - `Editor::default()`，初始无行。

- **步骤**：
  
  1. 调用 `append_line("l0")`；
  
  2. 调用 `append_line("l1")`；
  
  3. 调用 `pop_line()` 一次；
  
  4. 再调用 `pop_line()` 一次；
  
  5. 第三次调用 `pop_line()`。

- **预期结果**：
  
  - 两次 `append_line` 后，`count_lines() == 2`；
  
  - 前两次 `pop_line()` 成功，最终 `count_lines() == 0`；
  
  - 第三次 `pop_line()` 返回 `Err(AppError::...)`。

---

#### TC-E02：insert_text / delete_text 基本行为

- **模块**：Editor

- **用例编号**：TC-E02

- **用例名称**：插入与删除文本的基本行为

- **前置条件**：
  
  - `Editor` 中只有一行 `"hello world"`。

- **步骤**：
  
  1. 调用 `insert_text(1, 7, "rust ")`；
  
  2. 读取第 1 行内容；
  
  3. 调用 `delete_text(1, 7, 5)`；
  
  4. 再次读取第 1 行内容。

- **预期结果**：
  
  - 第 2 步内容为 `"hello rust world"`；
  
  - 第 4 步内容恢复为 `"hello world"`。

---

#### TC-E03：insert_text / delete_text 越界检查

- **模块**：Editor

- **用例编号**：TC-E03

- **用例名称**：插入/删除越界应返回错误

- **前置条件**：
  
  - Editor 内容为一行 `"abc"`。

- **步骤**：
  
  1. 调用 `insert_text(1, 10, "x")`（列越界）；
  
  2. 调用 `insert_text(2, 1, "x")`（行越界）；
  
  3. 调用 `delete_text(1, 3, 10)`（删除长度越界）；
  
  4. 调用 `delete_text(2, 1, 1)`（行越界）。

- **预期结果**：
  
  - 四次调用均返回 `Err(AppError::InvalidArgs(..))` 或等价错误。

---

#### TC-E04：undo / redo 命令栈行为

- **模块**：Editor

- **用例编号**：TC-E04

- **用例名称**：undo/redo 栈行为（基于 DocCommand）

- **前置条件**：
  
  - Editor 初始内容为 `["base"]`；
  
  - 构造两个实现 `DocCommand` 的命令：`AppendLineCommand("l1")` 和 `AppendLineCommand("l2")`。

- **步骤**：
  
  1. 依次执行 `exec_doc(cmd1)`、`exec_doc(cmd2)`；
  
  2. 调用 `undo()` 一次；
  
  3. 再调用 `undo()` 一次；
  
  4. 调用 `redo()` 两次。

- **预期结果**：
  
  - 初始：`["base"]`；
  
  - 执行两个命令后：`["base", "l1", "l2"]`；
  
  - 两次 undo 后：`["base"]`；
  
  - 两次 redo 后：`["base", "l1", "l2"]`；
  
  - `undo_stack` / `redo_stack` 状态与上述行为一致。

---

### 3.2 Workspace 层测试用例

#### TC-W01：resolve_path 解析逻辑

- **模块**：Workspace

- **用例编号**：TC-W01

- **用例名称**：路径解析（相对 / 绝对 / None）

- **前置条件**：
  
  - 使用测试辅助函数将 `Workspace.base_dir` 设置为 `tempdir/work_dir`。

- **步骤**：
  
  1. 调用 `resolve_path(Some("foo.txt"))`；
  
  2. 构造绝对路径 `abs`，调用 `resolve_path(Some(abs_str))`；
  
  3. 调用 `resolve_path(None)`。

- **预期结果**：
  
  - 第 1 步返回 `base_dir.join("foo.txt")`；
  
  - 第 2 步返回 `abs`；
  
  - 第 3 步返回 `base_dir`。

---

#### TC-W02：save_file 将 Editor 内容写入磁盘

- **模块**：Workspace

- **用例编号**：TC-W02

- **用例名称**：单文件保存

- **前置条件**：
  
  - `base_dir = tempdir/work_dir`；
  
  - `editors` 中插入一个 Editor，路径为 `foo.txt`，内容为 `"hello workspace"`；

- **步骤**：
  
  1. 调用 `save_file(&file_path)`；
  
  2. 从磁盘读取 `work_dir/foo.txt`。

- **预期结果**：
  
  - 文件存在；
  
  - 内容包含 `"hello workspace"`。

---

#### TC-W03：save_all 保存所有 Editor

- **模块**：Workspace

- **用例编号**：TC-W03

- **用例名称**：保存所有打开文件

- **前置条件**：
  
  - `base_dir = tempdir/work_dir`；
  
  - `editors` 中有两个 Editor：
    
    - `a.txt` 内容 `"AAAA"`；
    
    - `subdir/b.txt` 内容 `"BBBB"`；

- **步骤**：
  
  1. 调用 `save_all()`；
  
  2. 分别读取 `a.txt` 与 `subdir/b.txt` 内容。

- **预期结果**：
  
  - `a.txt` 内容 `"AAAA"`；
  
  - `b.txt` 内容 `"BBBB"`。

---

#### TC-W04：log_show 读取 `.filename.log`

- **模块**：Workspace

- **用例编号**：TC-W04

- **用例名称**：读取 per-file 日志

- **前置条件**：
  
  - `base_dir = tempdir/work_dir`；
  
  - 手动创建 `work_dir/.main.rs.log`，内容为 `"LOG CONTENT\nLINE 2"`；

- **步骤**：
  
  1. 调用 `log_show(&src)`，其中 `src = base_dir.join("main.rs")`；

- **预期结果**：
  
  - 返回内容为 `"LOG CONTENT\nLINE 2"`。

---

### 3.3 Application 层测试用例

#### TC-A01：保存工作区快照 `.editor_workspace`

- **模块**：Application

- **用例编号**：TC-A01

- **用例名称**：保存工作区 memento

- **前置条件**：
  
  - 使用测试构造函数 `new_test_app()` 创建 Application，`Workspace.base_dir = tempdir/work_dir`；

- **步骤**：
  
  1. 调用 `app.save_workspace_memento()`；
  
  2. 检查 `work_dir/.editor_workspace` 是否存在；
  
  3. 读取文件元数据，检查文件大小。

- **预期结果**：
  
  - `.editor_workspace` 文件存在；
  
  - 文件非空（长度 > 0）。

---

#### TC-A02：成功命令发布 `Event::Command`

- **模块**：Application + EventBus

- **用例编号**：TC-A02

- **用例名称**：命令执行成功事件发布

- **前置条件**：
  
  - 使用测试用 `EventBus` 与 `RecordingSubscriber`（基于 `Arc<Mutex<Vec<Event>>>`）；

- **步骤**：
  
  1. 使用 `router.resolve("load a.txt")` 获取 `(handler, args)`；
  
  2. 调用 `handler(&mut app, &args)` 得到 `Outcome`；
  
  3. 若 `Outcome.log` 为 `Some(cmd)`，调用  
     `bus.publish(Event::Command { file: workspace.active_file_path(), cmd })`；
  
  4. 在 `RecordingSubscriber` 中检查 `Vec<Event>`。

- **预期结果**：
  
  - 至少记录一条 `Event::Command { file: Some(path), cmd }`；
  
  - `cmd` 中包含 `"load"` 与 `"a.txt"`。

---

#### TC-A03：错误发布 `Event::Error`

- **模块**：Application + EventBus

- **用例编号**：TC-A03

- **用例名称**：错误事件发布

- **前置条件**：
  
  - 使用测试构造的 `Application` 与 `RecordingSubscriber`；

- **步骤**：
  
  1. 构造 `AppError::InvalidArgs("bad args".into())`；
  
  2. 调用 `app.publish_error(err)`；
  
  3. 检查记录的事件列表。

- **预期结果**：
  
  - 至少有一条 `Event::Error { code, message }`；
  
  - `message` 字符串中包含 `"bad args"`。

---

### 3.4 用户层随机测试（Fuzz）用例

> 注意：此处不是“单一确定的预期输出”，而是**测试稳定性与鲁棒性**，判断标准为“不崩溃 + 人工抽查日志无明显异常”。

#### TC-FZ01：多会话随机命令序列测试

- **模块**：整体系统（二进制 + 文件系统）

- **用例编号**：TC-FZ01

- **用例名称**：多会话随机命令序列 Fuzz 测试

- **前置条件**：
  
  - 在项目根目录执行 `cargo build`，生成 `target/debug/<bin>`；
  
  - Python 环境可用，存在脚本 `tests/random_cli_fuzz.py`；

- **脚本配置**：
  
  - `EDITOR_BIN_NAME = "<texteditor>"`
  
  - `SEED = 114514`（随机种子）
  
  - `NUM_SESSIONS = 4`（会话数）
  
  - `COMMANDS_PER_SESSION = 50`（每个会话随机命令数）

- **步骤**：
  
  1. 在项目根目录运行：
     
     ```bash
     python tests/random_test.py
     ```
  
  2. 脚本对每个 session 执行流程：
     
     - 在 `fuzz_runs/run_<i>` 下作为工作目录运行编辑器二进制；
     
     - 随机生成 `COMMANDS_PER_SESSION` 条命令，包括但不限于：
       
       - `load` / `append` / `init` / `editor-list` / `show` / `edit` / `save` / `undo` / `redo` / `dir-tree` / `log-on` / `log-off` / `log-show` / “垃圾命令（随机字符串）”；
       
       - 文件名 / 路径 / 文本内容随机生成；
     
     - 最后自动追加 `exit`；
     
     - 捕获 stdout / stderr / exit code；
     
     - 写入 `fuzz_runs/session_<i>.log`：包括命令列表、标准输出、标准错误；
  
  3. 自动检查：
     
     - 控制台打印每个 session 的 `exit code`；
     
     - 若 stderr 中包含 `"panic"` 字样，输出警告。
  
  4. 人工从 `fuzz_runs` 中随机选择若干 `session_<i>.log` 和对应的 `run_<i>/work_dir`，检查：
     
     - 是否存在明显错误日志（严重异常 / 非法状态）；
     
     - 文件内容与日志是否自洽（例如，未出现“命令成功但文件未改变”的明显逻辑错误）；
     
     - `.editor_workspace` 是否正常生成。

- **预期结果**：
  
  - 所有 session 的进程退出码为 0（无崩溃）；
  
  - stderr 中无 panic / backtrace；
  
  - 人工抽查的 session 中，未发现明显严重逻辑错误（如无限增长的垃圾文件、错误覆盖已存在文件等不符合设计的行为）。

- **实际结果**：
  
  - 在当前配置（`NUM_SESSIONS = 10`，`COMMANDS_PER_SESSION = 50`，`SEED = 114514`）下运行：
    
    - 所有 session 退出码均为 0；
    
    - stderr 未出现 `panic` 相关输出；
    
    - 抽查数个 `session_*.log` 文件及对应 `run_*/work_dir`，未发现明显异常行为，日志与文件状态与随机命令序列相符。

---

## 4. 测试结论

- **模块级单元测试**
  
  - Editor、Workspace、Application 三层核心逻辑通过了针对正常/异常路径的单元测试；
  
  - 行操作、undo/redo、路径解析、保存与日志读取等行为均符合设计预期。

- **随机用户层测试（Fuzz）**
  
  - 在多次随机命令序列的压力下，程序能够稳定运行；
  
  - 未出现 crash / panic；
  
  - 抽查 session 日志与文件系统状态未发现明显逻辑错误。

综合来看：

> 当前版本文本编辑器在实验要求范围内功能完整、行为稳定，  
> 模块级单元测试与随机用户层测试均通过，具备较好的鲁棒性和可维护性。
